---
title: "Final Project: Preprocessing"
author: "Josh Wilkins"
date: "7/30/2018"
output:
  html_document: default
  pdf_document: default
---

# Abstract
A collection of recipes were recorded and stored in individual files as a means of collaboration amongst the class. The most recent version of this data can be found [here](https://github.com/PeterClaussenSDSU/JoyOfCooking2018.git).

This file first attempts to:
- Fix file extensions
- Fix recipe file naming convention
- Remove duplicate recipes

It then proceeds to create a master list of all the recipes joined together by
- Joining tables (concatenating with rbind)
- Adding year and recipe columns to master list of recipes
- Standardizing to the 6 expected columns
- Convert amount column to weight

Libraries
```{r message=FALSE, warning=FALSE, include=FALSE}
library(stringr)
library(gsubfn)
library(data.table)
library(tidyverse)
```

Create cleaned up folder of recipe files

```{r}
old.path.to.recipes <- "../RecipeTables/"   # Path to original recipe files
path.to.recipes <- "../CleanRecipeTables/"  # Path for cleaned up recipe files

dir.create(file.path(".", path.to.recipes), showWarnings = FALSE)  # Create dir if it doesn't exists
unlink(paste(path.to.recipes, "*", sep=''))  # Remove everything from this new dir (start fresh if rerun R)

# Then copy all recipes to this new dir
invisible(file.copy(paste(old.path.to.recipes, list.files(old.path.to.recipes), sep=''), path.to.recipes))
```

Getting all the filenames of the recipes.

```{r}
recipe.files <- list.files(path = path.to.recipes)
num.recipes <- length(recipe.files)
```

Looking at filename extensions. renaming file if incorrect.

```{r}
removed.file.count <- 0  # Keep counter for files removed
extensions <- c()
for (recipe.file in recipe.files) {
  
  # Get the file extension
  extension <- tail(strsplit(recipe.file, '\\.')[[1]], n=1)
  
  # Find all unique file extensions
  if (!(extension %in% extensions) & extension != "tab") {
    print(recipe.file)  # Print recipe that has incorrect extension
    extensions <- append(extensions, extension) # And add extension to bad extension list
  }
  
  # If in txt format, just change it to .tab file extension
  if (extension == "txt") {
    old.file.name <- paste(path.to.recipes, recipe.file, sep='')
    str_sub(recipe.file, -3, -1) <- 'tab'
    new.file.name <- paste(path.to.recipes, recipe.file, sep='')
    if (file.exists(new.file.name)){
      removed.file.count <- removed.file.count + 1  # duplicate files
      cat("Replacing duplicate file: ", old.file.name, "\n")
    }
    file.rename(from = old.file.name, to = new.file.name)
  }
  
  # If not txt or tab format, assume no extension and add .tab file extension
  else if (extension != "tab") {
    old.file.name <- paste(path.to.recipes, recipe.file, sep='')
    new.file.name <- paste(path.to.recipes, recipe.file, '.tab', sep='')
    if (file.exists(new.file.name)){
      removed.file.count <- removed.file.count + 1  # duplicate files
      cat("Replacing duplicate file: ", old.file.name, "\n")
    }
    file.rename(from = old.file.name, to = new.file.name)
  } else {}
}

# Warn if encounter unexpected file extension
if (!is.null(extensions)) warnings(header="Unexpected File Extension(s)", thing)

# Reread filenames
recipe.files <- list.files(path = path.to.recipes)
```

Looks like there a couple files with no extension and a couple with a '.txt' extension.

Now try to format the recipe file names to Recipe.Name.Year.tab
Start by striping all the miscellaneous characters from the filenames and then just reformat it.
Grabbing all the years and recipe names while im at it.

```{r}
recipe.files <- list.files(path = path.to.recipes)

recipe.names <- c()  # Make a list of recipe names to later add to the tab files
years <- c()  # Make a list of recipe years to later add to the tab files
unique.recipes <- c()  # Keep track of unique recipes so we know which ones were removed

extensions <- c()
for (recipe.file in recipe.files) {
  old.file.name <- paste(path.to.recipes, recipe.file, sep='')

  # Remove recipes that was spelled two different ways... (Carmel vs Caramel, Babarian vs Bavarian, etc)
  if (grepl("CarmelCustard", recipe.file, ignore.case=TRUE) | grepl("Babarian", recipe.file, ignore.case=TRUE) |
      grepl("my\\.", recipe.file, ignore.case=TRUE) | grepl("withAsparagus", recipe.file, ignore.case=TRUE)) {
    
    cat("Duplicate, but mispelled file name removed", "\n")
    file.remove(old.file.name)  # Remove it
    removed.file.count <- removed.file.count + 1
    next
  }
  
  recipe.file <- gsub('\\.|_|-| ', '', recipe.file)  # Remove all crap from file names
  
  year <- str_extract(recipe.file, '\\d+')  # Grab the year from the file name
  
  # Check to see if more than one recipe exists (such as Meatloaf1, Meatloaf2, ...)
  if (nchar(year) == 5){
    year <- substr(year, 2, 5)
  }
  
  year.idx <- str_locate(recipe.file, year)[1]  # Grab the index of the year in the string
  
  # Some people made 2 digit year
  if (nchar(year) == 2) {
    year <- str_extract(recipe.file, '[0-9][0-9]')
    year.idx <- str_locate(recipe.file, year)[1]  # Grab the index of the year in the string

    # Make it 4 digits
    if (grepl("[1-9]", substr(year, 1, 1))) year <- paste("19", year, sep='')  # Year is 1900s if starts with 1-9
    else year <- paste("20", year, sep='')  # Year is 2000s if year starts with 0
  }

  if (grepl("[3-9]", substr(year, 1, 1))) {  # Remove file if has two years associated with it
    file.remove(old.file.name)  # Since someone probably merged
    removed.file.count <- removed.file.count + 1
    cat("Two years specified, removing file:\t", old.file.name, "\n")
    next
  }

  # In case some people didnt specify year
  if (is.na(year)) {
    cat("Year not specified: ", old.file.name, "\n")
  }
  
  years <- append(years, year)
  
  recipe.name <- str_sub(recipe.file, 1, year.idx-1)  # Now we know where the recipe name is
  recipe.names <- append(recipe.names, recipe.name)
  
  new.file.name <- paste(path.to.recipes, recipe.name, ".", year, ".tab", sep='')
  
  unique.name <- paste(tolower(recipe.name), ".", year, ".tab", sep='')
  if (unique.name %in% unique.recipes) {
    cat("Not going to duplicate file:\t\t", old.file.name, "\n")
    if (old.file.name != new.file.name) {
      file.remove(old.file.name)  # Need explicit removal here
    }
    removed.file.count <- removed.file.count + 1  # Otherwise its implicitly removed
    next
  } else {
    unique.recipes <- append(unique.recipes, unique.name)
  }
  
  # Rename everything, overwrites are ok, they remove duplicates (without caring which person was correct)
  file.rename(from = old.file.name, to = new.file.name)
}

cat("\nNumber of files removed: ", removed.file.count, "\n")

# Reread updated filenames
recipe.files <- list.files(path = path.to.recipes)

# Small check to make sure more files weren't removed than expected
if (length(recipe.files) != (num.recipes - removed.file.count)) warning("Unexpected removal of file(s)")

num.recipes <- length(recipe.files)  # Recalculate this to keep up to date
```


Read in the files into data tables
```{r, warning=FALSE}
# Ignore warnings (some people left the index in so mismatch number of cols to header)

recipe.list <- vector("list", length(recipe.files))

readFile <- function(recipe) {
  out <- tryCatch(
    expr = fread(paste(path.to.recipes, recipe, sep='')),
    error = function(e) {
      print(recipe) # Print the recipe name if we run into any errors
      print(e)  # And print the associated error
    }
  )
}

recipe.list <- lapply(recipe.files, readFile)  # Read each file into dataframe (and add to the list)
names(recipe.list) <- recipe.files  # Name the recipe tables in our list
```


# Merge tables

- Adding recipe name and year to each data table
- Removing V1 column
- Standardizing column names

```{r}

# Expected column names
correct.header <- c("Amount", "Measure", "Ingredient", "NDB_No", "Year", "Recipe")

# Placeholder to help join all the tab files
master.list <- NULL

# Placeholder for erroneous names that dont get matched by agrep
unmatched <- c()

for(idx in 1:length(recipe.files)) {

  file.name <- recipe.files[idx]
  tbl <- recipe.list[[file.name]]

  # Remove V1 column if it exists (From ppl writing index to tab files)
  if ("V1" %in% colnames(tbl)) {
    tbl$V1 <- NULL
  }
  
  # Then rename the columns to match the correct headers
  for (name in colnames(tbl)) {
    
    if (grepl("NBD", name, ignore.case=TRUE)) {
      match <- "NDB_No"  # The agrep function doesnt catch NBD vs NDB error
    } else if (grepl("Unit", name, ignore.case=TRUE)) {
      match <- "Measure" # The agrep function also won't match unit to measure
    } else {
      match <- agrep(name, correct.header, value=TRUE, ignore.case=TRUE)
    }
    
    # And print out the column name and file name if cant find a match
    if (identical(match, character(0)) & !(name %in% unmatched)) {
      unmatched <- append(unmatched, name)
      cat(file.name, ":", name, "\n")
      
      # Assume unmatched column is Recipe (some ppl made recipe the actual recipe name...)
      match <- "Recipe"
    }
    
    # Rename the column to the match (doesnt matter if exact match, rename anyways)
    names(tbl)[names(tbl) == name] <- match
  }

  # Type cast year column if it exists to numeric (removes some pointless warnings)
  if ("Year" %in% colnames(tbl)) {
    tbl$Year <- as.numeric(tbl$Year)
  }
  
  # And Replace whatever data is in year & recipe columns (also creates if non existent)
  tbl$Year <- as.numeric(years[idx])
  tbl$Recipe <- recipe.names[idx]

  # And finally join the table to the master list
  master.list <- rbind(master.list, tbl, fill=TRUE)
}

# Some more small checks for correct data manipulation efforts
if (!is.null(unmatched)) warnings(header="Unexpected column name, does not map to anything", unmatched)
if (length(colnames(master.list)) != 6) stop("Master Recipe list is wrong size!")
```


Rough attempt at replacing missing NDB numbers by finding similar ingredients in master list
```{r}
master.list$Ingredient <- tolower(master.list$Ingredient)
for(i in 1:nrow(master.list)) {
  row <- master.list[i,]
  
  if (!is.na(row$NDB_No)) next
  
  matches <- subset(master.list, row$Ingredient == master.list$Ingredient &
                                 row$Measure == master.list$Measure &
                                 !is.na(master.list$NDB_No))
  
  if (nrow(matches) != 0) master.list[i,]$NDB_No <- matches$NDB_No[1]
}
```


# Amount to Grams

Converting the amount column to grams
```{r}
#Reading in the weight table for conversion
weight.dat <-read.table("../SR-Leg_ASC/WEIGHT.txt",header=FALSE,sep="^",quote="~")
names(weight.dat) <- c("NDB_No","Seq","Amount","Msre_Desc","Gm_Wgt","Num_Data_Pts","Std_Dev")

# Remove any straggling NDB_No == NA for now
master.list <- master.list[!is.na(master.list$NDB_No),]
master.list$Measure <- as.character(master.list$Measure)

# If any of list in measurement description
grep.list <- function(cases, measure) {
  result <- FALSE
  for (case in cases) {
    result <- result | grepl(case, measure, ignore.case=TRUE)
  }
  return(result)
}

# Reverse of above (if measure in list of possible measurements)
grep.list2 <- function(measure, cases) {
  matches <- c()
  for (case in cases) {
    if (grepl(measure, case, ignore.case=TRUE)) matches <- append(matches, case)
  }
  return(matches)
}

# Like grep.list1 & grep.list2 combined, but removes all the matches from a list
remove.matches <- function(cases, possibles){
  matches <- c()
  for (case in cases) {
    matches <- append(matches, grep.list2(case, possibles))
  }
  return(setdiff(possibles, unique(matches)))
}

# Add the match to our master list given row and match (and scale by amounts)
add.match <- function(i, measure) {
  # Selects first match in case amounts are different
  weight <- subset(weight.dat$Gm_Wgt, (weight.dat$NDB_No == master.list[i,]$NDB & weight.dat$Msre_Desc == measure))[1]
  
  # Need to scale according to amount specified in weight table
  weight.amount <- subset(weight.dat$Amount, (weight.dat$NDB_No == master.list[i,]$NDB & weight.dat$Msre_Desc == measure))[1]
  master.list[i,]$Gm_Wgt <- weight * master.list[i,]$Amount / weight.amount
  
  match <- subset(weight.dat$Msre_Desc, (weight.dat$NDB_No == master.list[i,]$NDB & weight.dat$Msre_Desc == measure))[1]
  master.list[i,]$Matched_Measure <- as.character(match)
  return(master.list[i,])
}

format.measure <- function(measure) {
  if (grep.list(c("Tbs", "tbsp"), measure)) measure <- "tbsp"
  else if (grep.list(c("medium"), measure)) measure <- "medium"
  else if (grep.list(c("lrg", "Irg", "large", "thick"), measure)) measure <- "large"
  else if (grep.list(c("oz"), measure)) measure <- "oz"
  else if (grep.list(c("ea", "each", "pce", "pieces", "whole", "package"), measure)) measure <- "ea"
  else measure <- as.character(measure)
}

master.list$Measure <- sapply(master.list$Measure, format.measure)

master.list$Gm_Wgt <- 0 # Placeholder...
master.list$Matched_Measure <- '' # Placeholder...

# Do the replacement now

for(i in 1:nrow(master.list)) {
  row <- master.list[i,]
  
  # Find measure descriptions by matching NDBs
  possibles <- subset(weight.dat$Msre_Desc, weight.dat$NDB_No == row$NDB)
  
  # If not possible matches, means NDB doesnt exist in weight file
  if (length(possibles) == 0) {
    # print("NDB must be Invalid or nonexistent in weight.txt!")
    next
  }
  
  # If only one possible NDB match, then thats the one we take
  if (length(possibles) == 1) {
    master.list[i,] <- add.match(i, possibles)
    next
  }
  
  # If one of the possible matches is exact, take that one
  # Possible that there are multiples (the amounts could be different, take first & scale by amount)
  if (row$Measure %in% possibles) {
    master.list[i,] <- add.match(i, row$Measure)
    next
  }
  
  # The unit of 'ea' is hard - attempt to remove common units (oz, cup, tbsp, tsp)
  if (row$Measure == "ea") {
    possibles <- remove.matches(c("oz", "cup", "tbsp", "tsp"), possibles)
    
    # If one match left, take it
    if (length(possibles) == 1) {
      master.list[i,] <- add.match(i, possibles)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("medium", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("large", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("small", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # For debugging / cleaning
    # cat(row$Measure, " : ", as.character(row$Ingredient), " : ", as.character(possibles), "\n")
  }
  
  # If measure in any possible measure description
  matches <- grep.list2(row$Measure, possibles)
  if (length(matches) == 1) {
    master.list[i,] <- add.match(i, matches)
    next
  }
  
  # Convert tbsp to other measures to see if any more matches
  if (row$Measure == "tbsp") {
    matches <- grep.list2("tsp", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "tsp"
      master.list[i,]$Amount <-  master.list[i,]$Amount * 3
      master.list[i,] <- add.match(i, matches)
    }
    
    matches <- grep.list2("oz", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "oz"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 2
      master.list[i,] <- add.match(i, matches)
    }
  }
  
  # Convert tsp to tbsp to see if any more matches
  if (row$Measure == "tsp") {
    matches <- grep.list2("tbsp", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "tbsp"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 3
      master.list[i,] <- add.match(i, matches)
    }
    
    matches <- grep.list2("oz", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "oz"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 6
      master.list[i,] <- add.match(i, matches)
    }
  }
  
  # Temp thing to see which things havent changed # For debugging / cleaning
  # if (master.list[i,]$Gm_Wgt == 0) {
  #   thing <- subset(weight.dat$Msre_Desc, weight.dat$NDB_No == row$NDB)
  #   cat(row$Measure, " : ", as.character(row$Ingredient), " : ", as.character(thing), "\n")
  # }
}

# print(master.list[c("Measure", "Matched_Measure")])
```

Things not really considered:
- Multiple matches

Then remove all the recipes with an ingredient missing
```{r, warning=FALSE}
# Remove all recipes with any ingredient missing a weight
master.list <- master.list %>%
  group_by(Recipe, Year) %>%
  filter(!any(Gm_Wgt == 0))
```

How many recipes are we left with...
```{r}
nrow(unique(master.list[c("Recipe", "Year")]))
```

Not a great result with only about half of the recipes salvaged.

Modify the master list columns before writing it to csv:
- Remove measure column (replaceit with the matched measurement column)
```{r}
master.list$Measure <- NULL
names(master.list)[names(master.list) == 'Matched_Measure'] <- 'Measure'
```

Then write the master list to a file so that analyses can be performed. See Josh.Wilkins.Analysis for this.
```{r}
write.csv(master.list, "Ingredients.csv", row.names=FALSE)
```

```{r eval=FALSE}
# Check for validity if needed
print(master.list)
```
