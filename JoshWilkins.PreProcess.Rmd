---
title: "Final Project"
author: "Josh Wilkins"
date: "7/30/2018"
output:
  html_document: default
  pdf_document: default
---

# Abstract
A collection of recipes were recorded and stored in individual files as a means of collaboration amongst the class. The most recent version of this data can be found [here](https://github.com/PeterClaussenSDSU/JoyOfCooking2018.git).

TBD...


Libraries
```{r, warning=FALSE, message=FALSE}
library(stringr)
library(gsubfn)
library(data.table)
library(tidyverse)
```

Create cleaned up folder of recipe files

```{r}
old.path.to.recipes <- "./RecipeTables/"   # Path to original recipe files
path.to.recipes <- "./CleanRecipeTables/"  # Path for cleaned up recipe files

dir.create(file.path(".", path.to.recipes), showWarnings = FALSE)  # Create dir if it doesn't exists
unlink(paste(path.to.recipes, "*", sep=''))  # Remove everything from this new dir (start fresh if rerun R)

# Then copy all recipes to this new dir
invisible(file.copy(paste(old.path.to.recipes, list.files(old.path.to.recipes), sep=''), path.to.recipes))
```

Getting all the filenames of the recipes.

```{r}
recipe.files <- list.files(path = path.to.recipes)
num.recipes <- length(recipe.files)
```

Looking at filename extensions
Renaming file if incorrect

```{r}
removed.file.count <- 0  # Keep counter for files removed
extensions <- c()
for (recipe.file in recipe.files) {
  
  # Get the file extension
  extension <- tail(strsplit(recipe.file, '\\.')[[1]], n=1)
  
  # Find all unique file extensions
  if (!(extension %in% extensions) & extension != "tab") {
    print(recipe.file)  # Print recipe that has incorrect extension
    extensions <- append(extensions, extension) # And add extension to bad extension list
  }
  
  # If in txt format, just change it to .tab file extension
  if (extension == "txt") {
    old.file.name <- paste(path.to.recipes, recipe.file, sep='')
    str_sub(recipe.file, -3, -1) <- 'tab'
    new.file.name <- paste(path.to.recipes, recipe.file, sep='')
    if (file.exists(new.file.name)){
      removed.file.count <- removed.file.count + 1  # duplicate files
      cat("Replacing duplicate file: ", old.file.name, "\n")
    }
    file.rename(from = old.file.name, to = new.file.name)
  }
  
  # If not txt or tab format, assume no extension and add .tab file extension
  else if (extension != "tab") {
    old.file.name <- paste(path.to.recipes, recipe.file, sep='')
    new.file.name <- paste(path.to.recipes, recipe.file, '.tab', sep='')
    if (file.exists(new.file.name)){
      removed.file.count <- removed.file.count + 1  # duplicate files
      cat("Replacing duplicate file: ", old.file.name, "\n")
    }
    file.rename(from = old.file.name, to = new.file.name)
  } else {}
}

# Warn if encounter unexpected file extension
if (!is.null(extensions)) warnings(header="Unexpected File Extension(s)", thing)

# Reread filenames
recipe.files <- list.files(path = path.to.recipes)
```

Unllike the Midterm instruction that specified a '.tab' file extension, it looks like there a couple files with no extension and a couple with a '.txt' extension.


And then there is the file name itself...
Supposed to be in format of Recipe.Name.Year.tab

Well, we can make one assumption here, that all the files have a 4 digit year

I'm just going to strip all the miscellaneous characters from the filenames and reformat everything...
And grabbing all the years and recipe names while im at it

```{r}
recipe.files <- list.files(path = path.to.recipes)

recipe.names <- c()  # Make a list of recipe names to later add to the tab files
years <- c()  # Make a list of recipe years to later add to the tab files
unique.recipes <- c()  # Keep track of unique recipes so we know which ones were removed

extensions <- c()
for (recipe.file in recipe.files) {
  old.file.name <- paste(path.to.recipes, recipe.file, sep='')

  # Remove recipes that was spelled two different ways... (Carmel vs Caramel, Babarian vs Bavarian, etc)
  if (grepl("CarmelCustard", recipe.file, ignore.case=TRUE) | grepl("Babarian", recipe.file, ignore.case=TRUE) |
      grepl("my\\.", recipe.file, ignore.case=TRUE) | grepl("withAsparagus", recipe.file, ignore.case=TRUE)) {
    
    cat("Duplicate, but mispelled file name removed", "\n")
    file.remove(old.file.name)  # Remove it
    removed.file.count <- removed.file.count + 1
    next
  }
  
  recipe.file <- gsub('\\.|_|-| ', '', recipe.file)  # Remove all crap from file names
  
  year <- str_extract(recipe.file, '\\d+')  # Grab the year from the file name
  
  # Check to see if more than one recipe exists (such as Meatloaf1, Meatloaf2, ...)
  if (nchar(year) == 5){
    year <- substr(year, 2, 5)
  }
  
  year.idx <- str_locate(recipe.file, year)[1]  # Grab the index of the year in the string
  
  # Some people made 2 digit year
  if (nchar(year) == 2) {
    year <- str_extract(recipe.file, '[0-9][0-9]')
    year.idx <- str_locate(recipe.file, year)[1]  # Grab the index of the year in the string

    # Make it 4 digits
    if (grepl("[1-9]", substr(year, 1, 1))) year <- paste("19", year, sep='')  # Year is 1900s if starts with 1-9
    else year <- paste("20", year, sep='')  # Year is 2000s if year starts with 0
  }

  if (grepl("[3-9]", substr(year, 1, 1))) {  # Remove file if has two years associated with it
    file.remove(old.file.name)  # Since someone probably merged
    removed.file.count <- removed.file.count + 1
    cat("Two years specified, removing file:\t", old.file.name, "\n")
    next
  }

  # In case some people didnt specify year
  if (is.na(year)) {
    cat("Year not specified: ", old.file.name, "\n")
  }
  
  years <- append(years, year)
  
  recipe.name <- str_sub(recipe.file, 1, year.idx-1)  # Now we know where the recipe name is
  recipe.names <- append(recipe.names, recipe.name)
  
  new.file.name <- paste(path.to.recipes, recipe.name, ".", year, ".tab", sep='')
  
  unique.name <- paste(tolower(recipe.name), ".", year, ".tab", sep='')
  if (unique.name %in% unique.recipes) {
    cat("Not going to duplicate file:\t\t", old.file.name, "\n")
    if (old.file.name != new.file.name) {
      file.remove(old.file.name)  # Need explicit removal here
    }
    removed.file.count <- removed.file.count + 1  # Otherwise its implicitly removed
    next
  } else {
    unique.recipes <- append(unique.recipes, unique.name)
  }
  
  # Rename everything, overwrites are ok, they remove duplicates (without caring which person was correct)
  file.rename(from = old.file.name, to = new.file.name)
}

cat("\nNumber of files removed: ", removed.file.count, "\n")

# Reread updated filenames
recipe.files <- list.files(path = path.to.recipes)

# Small check to make sure more files weren't removed than expected
if (length(recipe.files) != (num.recipes - removed.file.count)) warning("Unexpected removal of file(s)")

num.recipes <- length(recipe.files)  # Recalculate this to keep up to date
```


Read in the files

```{r, warning=FALSE}
# Ignore warnings (some people left the index in so mismatch number of cols to header)

recipe.list <- vector("list", length(recipe.files))

readFile <- function(recipe) {
  out <- tryCatch(
    expr = fread(paste(path.to.recipes, recipe, sep='')),
    error = function(e) {
      print(recipe) # Print the recipe name if we run into any errors
      print(e)  # And print the associated error
    }
  )
}

recipe.list <- lapply(recipe.files, readFile)  # Read each file into dataframe (and add to the list)
names(recipe.list) <- recipe.files  # Name the recipe tables in our list
```


# Merge tables

Have to add recipe name and year to each file
Remove V1 column
Fix column names

```{r}

# Expected column names
correct.header <- c("Amount", "Measure", "Ingredient", "NDB_No", "Year", "Recipe")

# Placeholder to help join all the tab files
master.list <- NULL

# Placeholder for erroneous names that dont get matched by agrep
unmatched <- c()

for(idx in 1:length(recipe.files)) {

  file.name <- recipe.files[idx]
  tbl <- recipe.list[[file.name]]

  # Remove V1 column if it exists (From ppl writing index to tab files)
  if ("V1" %in% colnames(tbl)) {
    tbl$V1 <- NULL
  }
  
  # Then rename the columns to match the correct headers
  for (name in colnames(tbl)) {
    
    if (grepl("NBD", name, ignore.case=TRUE)) {
      match <- "NDB_No"  # The agrep function doesnt catch NBD vs NDB error
    } else if (grepl("Unit", name, ignore.case=TRUE)) {
      match <- "Measure" # The agrep function also won't match unit to measure
    } else {
      match <- agrep(name, correct.header, value=TRUE, ignore.case=TRUE)
    }
    
    # And print out the column name and file name if cant find a match
    if (identical(match, character(0)) & !(name %in% unmatched)) {
      unmatched <- append(unmatched, name)
      cat(file.name, ":", name, "\n")
      
      # Assume unmatched column is Recipe (some ppl made recipe the actual recipe name...)
      match <- "Recipe"
    }
    
    # Rename the column to the match (doesnt matter if exact match, rename anyways)
    names(tbl)[names(tbl) == name] <- match
  }

  # Type cast year column if it exists to numeric (removes some pointless warnings)
  if ("Year" %in% colnames(tbl)) {
    tbl$Year <- as.numeric(tbl$Year)
  }
  
  # And Replace whatever data is in year & recipe columns (also creates if non existent)
  tbl$Year <- as.numeric(years[idx])
  tbl$Recipe <- recipe.names[idx]

  # And finally join the table to the master list
  master.list <- rbind(master.list, tbl, fill=TRUE)
}

# Some more small checks for correct data manipulation efforts
if (!is.null(unmatched)) warnings(header="Unexpected column name, does not map to anything", unmatched)
if (length(colnames(master.list)) != 6) stop("Master Recipe list is wrong size!")
```

```{r}
# Rough attempt at replacing missing NDB numbers by finding similar ingredients in master list
master.list$Ingredient <- tolower(master.list$Ingredient)
for(i in 1:nrow(master.list)) {
  row <- master.list[i,]
  
  if (!is.na(row$NDB_No)) next
  
  matches <- subset(master.list, row$Ingredient == master.list$Ingredient &
                                 row$Measure == master.list$Measure &
                                 !is.na(master.list$NDB_No))
  
  if (nrow(matches) != 0) master.list[i,]$NDB_No <- matches$NDB_No[1]
}

# Write master list to a file
write.csv(master.list, "MasterList.csv", row.names=FALSE)
```


# Amount to Grams

Format the Measure columns in master data set

```{r}
master.list <- read.csv("MasterList.csv")

#Reading in the weight table for conversion
weight.dat <-read.table("./SR-Leg_ASC/WEIGHT.txt",header=FALSE,sep="^",quote="~")
names(weight.dat) <- c("NDB_No","Seq","Amount","Msre_Desc","Gm_Wgt","Num_Data_Pts","Std_Dev")

# Remove any straggling NDB_No == NA for now
master.list <- master.list[!is.na(master.list$NDB_No),]
master.list$Measure <- as.character(master.list$Measure)

# If any of list in measurement description
grep.list <- function(cases, measure) {
  result <- FALSE
  for (case in cases) {
    result <- result | grepl(case, measure, ignore.case=TRUE)
  }
  return(result)
}

# Reverse of above (if measure in list of possible measurements)
grep.list2 <- function(measure, cases) {
  matches <- c()
  for (case in cases) {
    if (grepl(measure, case, ignore.case=TRUE)) matches <- append(matches, case)
  }
  return(matches)
}

# Like grep.list1 & grep.list2 combined, but removes all the matches from a list
remove.matches <- function(cases, possibles){
  matches <- c()
  for (case in cases) {
    matches <- append(matches, grep.list2(case, possibles))
  }
  return(setdiff(possibles, unique(matches)))
}

# Add the match to our master list given row and match (and scale by amounts)
add.match <- function(i, measure) {
  # Selects first match in case amounts are different
  weight <- subset(weight.dat$Gm_Wgt, (weight.dat$NDB_No == master.list[i,]$NDB & weight.dat$Msre_Desc == measure))[1]
  master.list[i,]$Gm_Wgt <- weight
  
  match <- subset(weight.dat$Msre_Desc, (weight.dat$NDB_No == master.list[i,]$NDB & weight.dat$Msre_Desc == measure))[1]
  master.list[i,]$Matched_Measure <- as.character(match)
  return(master.list[i,])
}

format.measure <- function(measure) {
  if (grep.list(c("Tbs", "tbsp"), measure)) measure <- "tbsp"
  else if (grep.list(c("medium"), measure)) measure <- "medium"
  else if (grep.list(c("lrg", "Irg", "large", "thick"), measure)) measure <- "large"
  else if (grep.list(c("oz"), measure)) measure <- "oz"
  else if (grep.list(c("ea", "each", "pce", "pieces", "whole", "package"), measure)) measure <- "ea"
  else measure <- as.character(measure)
}

master.list$Measure <- sapply(master.list$Measure, format.measure)

master.list$Gm_Wgt <- 0 # Placeholder...
master.list$Matched_Measure <- 0 # Placeholder...

# Do the replacement now

for(i in 1:nrow(master.list)) {
  row <- master.list[i,]
  
  # Find measure descriptions by matching NDBs
  possibles <- subset(weight.dat$Msre_Desc, weight.dat$NDB_No == row$NDB)
  
  # If not possible matches, means NDB doesnt exist in weight file
  if (length(possibles) == 0) {
    # print("NDB must be Invalid or nonexistent in weight.txt!")
    next
  }
  
  # If only one possible NDB match, then thats the one we take
  if (length(possibles) == 1) {
    master.list[i,] <- add.match(i, possibles)
    next
  }
  
  # If one of the possible matches is exact, take that one
  # Possible that there are multiples (the amounts could be different, take first & scale by amount)
  if (row$Measure %in% possibles) {
    master.list[i,] <- add.match(i, row$Measure)
    next
  }
  
  # The unit of 'ea' is hard - attempt to remove common units (oz, cup, tbsp, tsp)
  if (row$Measure == "ea") {
    possibles <- remove.matches(c("oz", "cup", "tbsp", "tsp"), possibles)
    
    # If one match left, take it
    if (length(possibles) == 1) {
      master.list[i,] <- add.match(i, possibles)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("medium", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("large", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # Otherwise take medium, then large or small
    matches <- grep.list2("small", possibles)
    if (length(matches) == 1) {
      master.list[i,] <- add.match(i, matches)
      next
    }
    
    # For debugging / cleaning
    # cat(row$Measure, " : ", as.character(row$Ingredient), " : ", as.character(possibles), "\n")
  }
  
  # If measure in any possible measure description
  matches <- grep.list2(row$Measure, possibles)
  if (length(matches) == 1) {
    master.list[i,] <- add.match(i, matches)
    next
  }
  
  # Convert tbsp to other measures to see if any more matches
  if (row$Measure == "tbsp") {
    matches <- grep.list2("tsp", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "tsp"
      master.list[i,]$Amount <-  master.list[i,]$Amount * 3
      master.list[i,] <- add.match(i, matches)
    }
    
    matches <- grep.list2("oz", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "oz"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 2
      master.list[i,] <- add.match(i, matches)
    }
  }
  
  # Convert tsp to tbsp to see if any more matches
  if (row$Measure == "tsp") {
    matches <- grep.list2("tbsp", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "tbsp"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 3
      master.list[i,] <- add.match(i, matches)
    }
    
    matches <- grep.list2("oz", possibles)
    if (length(matches) == 1) {
      master.list[i,]$Measure <- "oz"
      master.list[i,]$Amount <-  master.list[i,]$Amount / 6
      master.list[i,] <- add.match(i, matches)
    }
  }
  
  # Temp thing to see which things havent changed # For debugging / cleaning
  # if (master.list[i,]$Gm_Wgt == 0) {
  #   thing <- subset(weight.dat$Msre_Desc, weight.dat$NDB_No == row$NDB)
  #   cat(row$Measure, " : ", as.character(row$Ingredient), " : ", as.character(thing), "\n")
  # }
}

# print(master.list[c("Measure", "Matched_Measure")])
nrow(subset(master.list, Gm_Wgt != 0))
```

Dont forget:
- Scale by amount
- Remove or fix NA in NDB column
- Multiple matches
- Unimportant ingredients

```{r}
# Remove all recipes with any ingredient missing a weight
master.list <- master.list %>%
  group_by(Recipe, Year) %>%
  filter(!any(Gm_Wgt == 0))
```


How many recipes are we left with...
```{r}
nrow(unique(master.list[c("Recipe", "Year")]))
```


Helper function (debug only)
```{r}
function(measure) {
  # prints mesurement description give NDBs associated with a measurement name
  NDBs <- subset(master.list$NDB_No, grepl(measure, master.list$Measure))
  for (NDB in unique(NDBs[!is.na(NDBs)])) {
    print(subset(weight.dat$Msre_Desc, weight.dat$NDB_No == NDB))
  }
}
```


```{r}
print(unique(master.list$Measure))
```










```{r}
print(weight.dat)
```

```{r}
print(master.list)
```

